--SkillActionCollider.txt
--@breif 碰撞
--@data 2018/03/22

--@brief c#引用
local CSLog = CS.GameTool.Log
local CSVector3 = CS.UnityEngine.Vector3
local CSAngleBetween = CS.GameTool.SignedAngleBetween
local CSQuaternion = CS.UnityEngine.Quaternion
local CSGameObject = CS.UnityEngine.GameObject

SkillActionCollider = {
	m_nOffset = nil,	--偏移
	m_ztCollider = nil,		--碰撞体
	m_skillLayer = nil,		--位置类型
	m_targetType = nil,		--目标类型

	m_tInColliders = nil,	--已经碰撞队列
	m_tColliderTargets = nil, --目标对象
	m_nColliderMax = nil,	--碰撞总数

	m_colliderView = nil,	--碰撞显示

	m_spriteEffName = nil,	--特效名字
	m_spriteEffGo = nil,	--特效实例
}

--@breif 继承SkillAction
setmetatable( SkillActionCollider, { __index = SkillAction})

--————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
--*******************************************************Public Begin*************************************************************
--————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
--@brief 拷贝原表
function SkillActionCollider:Create(actionParse,actionData)
	local obj = {}
	setmetatable( obj, { __index = SkillActionCollider })
	obj:Init(actionParse,actionData)
	return obj
end

--@brief 初始化
function SkillActionCollider:Init(actionParse,actionData)
	--继承实现
	SkillAction.Init(self,actionParse,actionData)
	self.m_nActionType = SkillActionType.Collider

	self.m_nOffset = CSVector3(self.m_tActionData.m_nOffsetX,0,self.m_tActionData.m_nOffsetZ)
	self.m_ztCollider = self.m_tActionData.m_ztCollider
	self.m_skillLayer = self.m_tActionData.m_skillLayer
	self.m_targetType = self.m_tActionData.m_targetType
	
	self.m_nColliderMax = self.m_tActionData.m_nColliderMax
	self.m_spriteEffName = self.m_tActionData.m_spriteEffName
	self:_GetTargetList()
end

--@brief 开始
function SkillActionCollider:Start()
	--继承实现
	SkillAction.Start(self)
	self:_SetStartPos()
	self:_CreateEffect()
end


-- --@brief 更新
function SkillActionCollider:Update()
	--继承实现
	SkillAction.Update(self)
	self:_CheckCollider()
	self:_UpdateColliderView()
	self:_UpdateEffect()
end

--@brief 结束
function SkillActionCollider:Done()
	--继承实现
	SkillAction.Done(self)
end

--@brief 移除
function SkillActionCollider:Destroy()
	--继承实现
	SkillAction.Destroy(self)
	
	if self.m_colliderView then
		CS.UnityEngine.GameObject.Destroy(self.m_colliderView)
		self.m_colliderView = nil
	end

	if self.m_spriteEffGo then
		CS.UnityEngine.GameObject.Destroy(self.m_spriteEffGo)
		self.m_spriteEffGo = nil
	end
end

--@brief 结束标记
function SkillAction:IsFinish()
	return self.m_bFinish
end


--————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
--*******************************************************Public End***************************************************************
--————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
--@brief 设置起始位置
function SkillActionCollider:_SetStartPos()
	if self.m_skillLayer == SkillLayerType.Hero then
		self.m_ztCollider:SetPos(self.m_tOwner:GetColliderPos())
	else
		self.m_ztCollider:SetPos(self.m_tSkillPos)
	end
	local face = self.m_tOwner:GetFacePos()
	local angle = CSAngleBetween(face,CSVector3.forward)
 	
	local rot = CSQuaternion.Euler(0, angle, 0)
	self.m_nOffset =  rot * self.m_nOffset

	self.m_ztCollider.m_tPos.x = self.m_ztCollider.m_tPos.x + self.m_nOffset.x
	self.m_ztCollider.m_tPos.z = self.m_ztCollider.m_tPos.z + self.m_nOffset.z

	self:_UpdateColliderView()
end

--@brief 获得方向
function SkillActionCollider:_GetTargetList()
	self.m_tInColliders = {}
	self.m_tColliderTargets = GlobalBattleCtrl:GetTargetList(self.m_tOwner:GetBattleId(),self.m_targetType,self.m_nTargetId)
end

--@brief checkCollider
function SkillActionCollider:_CheckCollider()

	local list = {}
	for i,chara in pairs(self.m_tColliderTargets) do
		local battleId = chara:GetBattleId()

		local isInCollider = self:_CheckInColliderList(battleId)
		if  isInCollider then
			break
		end

		local collider = chara:GetCollider() 
		if BattleDefine:CheckCollider(collider,self.m_ztCollider) then
			table.insert(self.m_tInColliders,battleId)
			table.insert(list,battleId)
		end
	end
	if self:IsHost() and #list > 0 then
		return BattleCommandProtocol:SendColliderCommand(self:GetSkillId(),self.m_ztCollider.m_tPos,list)
	end
end

--@brief 判断是否存在碰撞队列里
function SkillActionCollider:_CheckInColliderList(battleId)
	for i,v in pairs(self.m_tInColliders) do
		if v == battleId then
			return true
		end
	end
	return false
end

--@brief 创建特效
function SkillActionCollider:_CreateEffect()
	if not self.m_spriteEffName then
		return
	end

	self.m_spriteEffGo = CSGameObject("ColliderEffect")
	CS.AssetManager.LoadAsset(PathManager:GetMapParticle(self.m_spriteEffName),function (target,path)
		if target and self.m_spriteEffGo then
			local go = CSGameObject.Instantiate(target,self.m_spriteEffGo.transform)
		end
	end)
end
--[[
 if (null == _colliderEffect)
        {
            _colliderEffect = new GameObject();
            _colliderEffect.name = "EffectCon";
            _colliderEffect.transform.localRotation = Quaternion.Euler(Vector3.up * _collider.rotate);
            _colliderEffect.transform.localPosition = new Vector3(_collider.x, 0.1f, _collider.y);
            _colliderEffect.transform.SetParent(GameObject.Find("PlayerLayer").transform,false);
        }
        if(null !=_colliderInfo.EffectInfos && _colliderInfo.EffectInfos.Count > 0){
            for (int i = 0; i < _colliderInfo.EffectInfos.Count; i++)
            {
                EffectInfo effectInfo = _colliderInfo.EffectInfos[i];
                _effectCounter.AddEffect(effectInfo, _colliderEffect.transform);
            }
        }
 ]]

--@brife 更新特效位置
function SkillActionCollider:_UpdateEffect()
	if not self.m_spriteEffGo then
		return
	end
	self.m_spriteEffGo.transform.position = self.m_ztCollider.m_tPos
end

--@brief 显示碰撞
function SkillActionCollider:_UpdateColliderView()
	if not GameConfig.IsSkillDebugScene then
		return
	end
	if not self.m_colliderView then
		self.m_colliderView =  CS.UnityEngine.GameObject.CreatePrimitive(CS.UnityEngine.PrimitiveType.Cylinder);
	end
	local scaleX = self.m_ztCollider.m_nRaidus
	local scaleY = (self.m_ztCollider.m_nRaidus * 2 + self.m_ztCollider.m_nHeight) /2
	self.m_colliderView.transform.localScale = {x = scaleX,y = scaleY,z = scaleX}
    self.m_colliderView.transform.position = self.m_ztCollider.m_tPos
end